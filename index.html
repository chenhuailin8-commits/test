<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Three.js 多模型切换展示</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        #video-input { display: none; }

        /* 摄像头窗口 */
        .camera-box {
            position: absolute; bottom: 20px; right: 20px; width: 240px; height: 180px;
            border-radius: 12px; overflow: hidden; border: 2px solid #333; background: #000; z-index: 10;
            pointer-events: none;
        }
        #output-canvas { width: 100%; height: 100%; transform: scaleX(-1); object-fit: cover; }

        /* 左侧模型列表 UI */
        #model-list {
            position: absolute; top: 20px; left: 20px; z-index: 20;
            display: flex; flex-direction: column; gap: 10px;
            width: 160px;
        }
        
        .model-btn {
            background: rgba(0, 20, 40, 0.6);
            color: #00ffff;
            border: 1px solid rgba(0, 255, 255, 0.3);
            padding: 12px;
            cursor: pointer;
            text-align: left;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            transition: all 0.3s;
            font-weight: bold;
            position: relative;
            overflow: hidden;
        }

        .model-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            border-color: #00ffff;
            transform: translateX(5px); /* 悬停时右移一点 */
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        }

        .model-btn.active {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        /* 状态栏 */
        #status-bar {
            position: absolute; bottom: 210px; right: 20px; text-align: right;
            color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.8); pointer-events: none;
        }
    </style>

    <!-- 基础库 -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tweakpane@3.0.7/dist/tweakpane.min.js"></script>
</head>
<body>

    <!-- 左侧模型选择按钮容器 -->
    <div id="model-list">
        <!-- 按钮会通过 JS 自动生成 -->
    </div>

    <video id="video-input"></video>
    
    <div id="status-bar">
        <div>当前模型: <span id="current-model-name" style="color:#00ff00; font-weight:bold;">基础球体</span></div>
        <div>交互状态: <span id="mode-text" style="color:#aaa">初始化...</span></div>
    </div>

    <div class="camera-box">
        <canvas id="output-canvas"></canvas>
    </div>

    <!-- 核心逻辑 -->
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/loaders/GLTFLoader.js';
        import { MeshSurfaceSampler } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/math/MeshSurfaceSampler.js';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';

        // =========================================================================
        // Step A: 配置你的模型列表 (在这里修改！)
        // =========================================================================
        const PRESET_MODELS = [
            { name: "⚡ 基础能量球", path: "default" }, // 这是一个数学生成的球体，不用文件
            { name: "青铜鼎", path: "models/ding.glb"},
            { name: "布老虎", path: "models/hu.glb" },
            // ⬇️ 修改这里：把 'path' 改成你 models 文件夹里的实际文件名
            // { name: "青铜鼎", path: "./models/青铜鼎.glb" }, 
            // { name: "布老虎", path: "./models/布老虎.glb" },
            
            // 示例占位符 (你可以删掉或改成你自己的)
            { name: "示例: 立方体", path: "cube" }, 
        ];
        // =========================================================================


        // 1. 场景初始化
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.0005);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        camera.position.set(0, 0, 600);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.0;

        // 2. 粒子系统
        const PARTICLE_COUNT = 25000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        const centerPositions = new Float32Array(PARTICLE_COUNT * 3);
        const scatterPositions = new Float32Array(PARTICLE_COUNT * 3);
        const randomOffsets = new Float32Array(PARTICLE_COUNT * 3);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            positions[i*3] = (Math.random()-0.5)*1000;
            positions[i*3+1] = (Math.random()-0.5)*1000;
            positions[i*3+2] = (Math.random()-0.5)*1000;

            // 凝聚中心
            const r = 5 * Math.random();
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            centerPositions[i*3] = r * Math.sin(phi) * Math.cos(theta);
            centerPositions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            centerPositions[i*3+2] = r * Math.cos(phi);

            // 散开位置
            const sr = 1000 + Math.random() * 1500;
            const st = Math.random() * Math.PI * 2;
            const sp = Math.acos(2 * Math.random() - 1);
            scatterPositions[i*3] = sr * Math.sin(sp) * Math.cos(st);
            scatterPositions[i*3+1] = sr * Math.sin(sp) * Math.sin(st);
            scatterPositions[i*3+2] = sr * Math.cos(sp);

            randomOffsets[i*3] = Math.random() * 100;
            randomOffsets[i*3+1] = Math.random() * 100;
            randomOffsets[i*3+2] = Math.random() * 100;
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        // 粒子外观
        const material = new THREE.PointsMaterial({
            color: 0x00ffff, size: 4.0, transparent: true, opacity: 0.85,
            blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: true
        });
        // 贴图
        const canvas = document.createElement('canvas');
        canvas.width=32; canvas.height=32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16,16,0,16,16,16);
        grad.addColorStop(0, 'rgba(255,255,255,1)'); grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle=grad; ctx.fillRect(0,0,32,32);
        material.map = new THREE.CanvasTexture(canvas);
        
        scene.add(new THREE.Points(geometry, material));


        // =========================================================================
        // Step B: 模型切换逻辑
        // =========================================================================
        const gltfLoader = new GLTFLoader();
        const statusName = document.getElementById('current-model-name');
        const btnContainer = document.getElementById('model-list');

        // 默认球体生成器
        function setSphereTargets() {
            const r = 200;
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const phi = Math.acos(-1+(2*i)/PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT*Math.PI)*phi;
                targetPositions[i*3] = r*Math.cos(theta)*Math.sin(phi);
                targetPositions[i*3+1] = r*Math.sin(theta)*Math.sin(phi);
                targetPositions[i*3+2] = r*Math.cos(phi);
            }
            material.color.setHex(0x00ffff);
        }

        // 默认立方体生成器
        function setCubeTargets() {
             const s = 300;
             for(let i=0; i<PARTICLE_COUNT; i++) {
                targetPositions[i*3] = (Math.random()-0.5)*s;
                targetPositions[i*3+1] = (Math.random()-0.5)*s;
                targetPositions[i*3+2] = (Math.random()-0.5)*s;
             }
             material.color.setHex(0xff00ff);
        }

        // 核心：加载模型函数
        function loadModel(path, name) {
            statusName.innerText = "加载中: " + name + "...";
            
            // 特殊情况处理
            if (path === "default") {
                setSphereTargets();
                statusName.innerText = name;
                return;
            }
            if (path === "cube") {
                setCubeTargets();
                statusName.innerText = name;
                return;
            }

            // 加载 GLB/GLTF
            gltfLoader.load(path, (gltf) => {
                let mesh = null;
                gltf.scene.traverse(child => { if(child.isMesh && !mesh) mesh = child; });
                
                if(mesh) {
                    mesh.updateMatrixWorld(true);
                    mesh.geometry.computeBoundingBox();
                    const box = mesh.geometry.boundingBox;
                    const size = new THREE.Vector3(); box.getSize(size);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 300 / maxDim; // 统一缩放到 300

                    const sampler = new MeshSurfaceSampler(mesh).build();
                    const temp = new THREE.Vector3();

                    for(let i=0; i<PARTICLE_COUNT; i++) {
                        sampler.sample(temp);
                        targetPositions[i*3] = temp.x * scale;
                        targetPositions[i*3+1] = temp.y * scale;
                        targetPositions[i*3+2] = temp.z * scale;
                    }
                    statusName.innerText = name;
                    material.color.setHex(0xffffff); // 加载模型后变白
                } else {
                    alert("该模型没有 Mesh 数据");
                }
            }, undefined, (err) => {
                console.error(err);
                statusName.innerText = "加载失败 (请检查路径)";
                alert("找不到文件: " + path + "\n请确保 models 文件夹在正确位置");
            });
        }

        // 自动生成按钮
        PRESET_MODELS.forEach((model, index) => {
            const btn = document.createElement('div');
            btn.className = 'model-btn';
            btn.innerText = model.name;
            if(index === 0) btn.classList.add('active'); // 默认选中第一个

            btn.onclick = () => {
                // 移除其他按钮激活状态
                document.querySelectorAll('.model-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                loadModel(model.path, model.name);
            };
            btnContainer.appendChild(btn);
        });

        // 初始化默认模型
        setSphereTargets();


        // =========================================================================
        // Step C: 手势 & 动画
        // =========================================================================
        const video = document.getElementById('video-input');
        const outCanvas = document.getElementById('output-canvas');
        const outCtx = outCanvas.getContext('2d');
        const modeText = document.getElementById('mode-text');

        let interactionMode = 'NORMAL';
        let handOpenness = 1.0; 
        let smoothOpenness = 1.0;

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5});
        hands.onResults(results => {
            outCanvas.width = video.videoWidth; outCanvas.height = video.videoHeight;
            outCtx.clearRect(0,0,outCanvas.width,outCanvas.height);
            outCtx.drawImage(results.image,0,0,outCanvas.width,outCanvas.height);
            
            if(results.multiHandLandmarks.length>0) {
                const lm = results.multiHandLandmarks[0];
                drawConnectors(outCtx, lm, HAND_CONNECTIONS, {color: '#00ffff'});
                drawLandmarks(outCtx, lm, {color: '#fff', radius: 2});

                const wrist = lm[0];
                const dist = (idx) => Math.hypot(lm[idx].x-wrist.x, lm[idx].y-wrist.y);
                const iUp=dist(8)>dist(6), mUp=dist(12)>dist(10), rDown=dist(16)<dist(14), pDown=dist(20)<dist(18);

                if(iUp && mUp && rDown && pDown) {
                    interactionMode = 'SCATTER';
                    modeText.innerText = "✌️ 粒子消散";
                    modeText.style.color = "#ff00ff";
                } else {
                    interactionMode = 'NORMAL';
                    const d = Math.hypot(lm[4].x-lm[17].x, lm[4].y-lm[17].y);
                    handOpenness = Math.max(0, Math.min(1, (d-0.05)*5));
                    if(handOpenness>0.5) {
                        modeText.innerText = "✨ 模型展示"; modeText.style.color="#00ffff";
                    } else {
                        modeText.innerText = "⚛️ 核心凝聚"; modeText.style.color="#ffaa00";
                    }
                }
            } else {
                interactionMode = 'NORMAL'; handOpenness=1.0;
                modeText.innerText = "等待手势..."; modeText.style.color="#aaa";
            }
        });
        const cam = new Camera(video, {onFrame: async()=>{await hands.send({image:video})}, width:640, height:480});
        cam.start();

        // UI面板
        const params = { modelScale: 1.0, scatterSpeed: 0.02, floatSpeed: 1.0 };
        const pane = new Tweakpane.Pane({title:'参数调整'});
        pane.addInput(params, 'modelScale', {min:0.5, max:3.0, label:'模型大小'});
        pane.addInput(params, 'scatterSpeed', {min:0.01, max:0.1, label:'消散速度'});

        // 动画循环
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            const time = clock.getElapsedTime();
            
            smoothOpenness += (handOpenness - smoothOpenness) * 0.1;
            const p = geometry.attributes.position.array;

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const idx = i*3;
                const px = p[idx], py = p[idx+1], pz = p[idx+2];
                let tx, ty, tz, speed;

                // 随机浮动 (Noise)
                const fx = Math.sin(time * params.floatSpeed + randomOffsets[idx]) * 3;
                const fy = Math.cos(time * params.floatSpeed * 0.8 + randomOffsets[idx+1]) * 3;
                const fz = Math.sin(time * params.floatSpeed * 0.5 + randomOffsets[idx+2]) * 3;

                if(interactionMode === 'SCATTER') {
                    // 消散模式
                    tx = scatterPositions[idx] + fx * 10;
                    ty = scatterPositions[idx+1] + fy * 10;
                    tz = scatterPositions[idx+2] + fz * 10;
                    speed = params.scatterSpeed; // 慢速
                } else {
                    // 正常模式
                    const cx=centerPositions[idx], cy=centerPositions[idx+1], cz=centerPositions[idx+2];
                    const tax=targetPositions[idx], tay=targetPositions[idx+1], taz=targetPositions[idx+2];
                    const s = params.modelScale;
                    
                    tx = cx + (tax*s - cx) * smoothOpenness + fx;
                    ty = cy + (tay*s - cy) * smoothOpenness + fy;
                    tz = cz + (taz*s - cz) * smoothOpenness + fz;
                    speed = 0.08;
                }
                
                p[idx] += (tx - px) * speed;
                p[idx+1] += (ty - py) * speed;
                p[idx+2] += (tz - pz) * speed;
            }
            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>